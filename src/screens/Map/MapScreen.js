import React, { Component } from "react";import { connect } from "react-redux";import { Animated, Dimensions, Easing, Image, PanResponder, ScrollView, StyleSheet, View } from "react-native";import { BlurView, LinearGradient } from "expo";import * as actions from "../../actions/index";import Icon from "react-native-vector-icons/MaterialIcons";import GeoFire from "geofire";import { firedb } from "../../modules/firebase";import MapContainer from "../../components/Map/MapContainer";import { defaultRegion, loadingImages } from "../../../config/setting/defaultValues";import ProfileView from "../../components/Map/ProfileView";import ModalSpinner from "../../components/Common/ModalSpinner";import SearchArea from "../../components/Map/SearchArea";import Carousel, { Pagination } from "react-native-snap-carousel";import Spinner from "../../components/Common/Spinner";let { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get("window");SCREEN_HEIGHT -= 0;const SCREEN_RATIO = SCREEN_WIDTH / SCREEN_HEIGHT;const INTRO_CAROUSEL_HEIGHT = 200;const TAB_HEIGHT = 50;const PROFILE_MIN_Y = INTRO_CAROUSEL_HEIGHT + 50;const PROFILE_MAX_Y = SCREEN_HEIGHT - PROFILE_MIN_Y;const PROFILE_INTRO_OFFSET = PROFILE_MIN_Y - INTRO_CAROUSEL_HEIGHT;const AnimatedBlurView = Animated.createAnimatedComponent(BlurView);const COLORS = [  "#F38181",  "#66CCCC",  "#6c81ea",  "#FCE38A",  "#FF7676",  "#3BB2B8",  "#f085ed",  "#57CA85",  "#66CCCC"];//const GRADIENTS = [["#F38181", "#66CCCC"], ["#66CCCC", "#FCE38A"], ["#FCE38A", "#FF7676"], ["#c8e6b0", "#3BB2B8"],// ["#F02FC2", "#6094EA"], ["#5B247A", "#1BCEDF"], ["#184E68", "#57CA85"]];const AnimatedIcon = Animated.createAnimatedComponent(Icon);class MapScreen extends Component {  /*static navigationOptions = {    //drawerLockMode: "locked-open",    //header: null,    tabBarIcon: ({ tintColor }) => {      return <Icon name="place" color={tintColor} size={20} type="materialicons" />;    }  };*/  constructor(props) {    super(props);    this.state = {      region: defaultRegion,      radius: 10,      dataLoading: false,      orgsSearchedID: [],      petsForCarousel: [], //DEFAULT_SAMPLE, //[]      focusedOrgID: -1,      focusedIntroPetIndex: 0,      focusedIntroPetIndexPrev: 0,      focusedProfileImageIndex: 0,      //these two only contain geo locations from firedb      geoMarkersCurrentSearchResults: {},      //geoMarkersAllSearchResultsSaved: {},      //animations      anime_bottomUIShowUp: new Animated.Value(0),      anime_profileSwipe: new Animated.Value(300),      anime_profileAfterSwipe: new Animated.Value(0),      anime_introCarouselSwipe: new Animated.Value(0),      anime_profileScrollDown: new Animated.Value(0),      isScrolledUp: false,      isMapBlurEnabled: false,      petSwitchFlag: false    };    this.scrollOffset = 0;    this.anime_bottomUIShowUp = Animated.timing(      this.state.anime_bottomUIShowUp,      {        toValue: 300,        easing: Easing.linear      }    );    this.anime_introCarouselSwipe = Animated.timing(      this.state.anime_introCarouselSwipe,      {        toValue: 300,        duration: 300,        easing: Easing.linear      }    );    this._panResponder = PanResponder.create({      onMoveShouldSetPanResponder: (evt, gestureState) => {        if (          (this.state.isScrolledUp &&            this.scrollOffset <= 0 &&            gestureState.dy > 10 &&            Math.abs(gestureState.dy) > Math.abs(gestureState.dx) * 2) ||          (!this.state.isScrolledUp &&            gestureState.dy <= 0 &&            Math.abs(gestureState.dy) > Math.abs(gestureState.dx) * 2)        ) {          return true;        }        return false;      },      onPanResponderGrant: (evt, gestureState) => {        this.setState({ isMapBlurEnabled: true });        this.state.anime_profileSwipe.extractOffset();      },      onPanResponderMove: (evt, gestureState) => {        this.state.anime_profileSwipe.setValue(gestureState.dy);      },      onPanResponderRelease: (evt, gestureState) => {        this.state.anime_profileSwipe.flattenOffset();        const { dy, moveY } = gestureState;        if (moveY > PROFILE_MAX_Y + 100) {          this.state.anime_profileAfterSwipe.setValue(0);          this.setState({ isScrolledUp: false, isMapBlurEnabled: false });          console.log("1");          Animated.timing(this.state.anime_profileSwipe, {            toValue: 300,            tension: 1          }).start();        } else if (moveY < PROFILE_MIN_Y) {          this.setState({ isScrolledUp: true, isMapBlurEnabled: true });          console.log("2");          Animated.parallel([            Animated.timing(this.state.anime_profileSwipe, {              toValue: 0            }),            Animated.timing(this.state.anime_profileAfterSwipe, {              toValue: 300,              delay: 500            })          ]).start();        } else if (dy <= 0) {          console.log("3");          this.setState({ isScrolledUp: true, isMapBlurEnabled: true });          Animated.parallel([            Animated.timing(this.state.anime_profileSwipe, {              toValue: 0            }),            Animated.timing(this.state.anime_profileAfterSwipe, {              toValue: 300,              delay: 500            })          ]).start();          //this.state.anime_profileSwipe.setValue(-PROFILE_MAX_Y)        } else if (dy > 0) {          console.log("4");          this.state.anime_profileAfterSwipe.setValue(0);          Animated.parallel([            Animated.timing(this.state.anime_profileSwipe, {              toValue: 300            }),            Animated.timing(this.state.anime_profileAfterSwipe, {              toValue: 0            })          ]).start(            this.setState({ isScrolledUp: false, isMapBlurEnabled: false })          );        }      }    });    this.markersHolder = {};    this.geoFire = new GeoFire(firedb.ref("orgs"));    this.geoQuery = this.geoFire.query({      center: [this.state.region.latitude, this.state.region.longitude],      // do not set to 0, will cause performance issue      radius: 1    });    this.geoQuery.on("ready", () => {      console.log("MAP geofire ready");      this.setState({        geoMarkersCurrentSearchResults: this.markersHolder,        dataLoading: false      });    });    this.geoQuery.on("key_entered", (key, location, distance) => {      console.log("MAP geofire key_entered", key);      this.setState({ dataLoading: true });      this.markersHolder[key] = { key, location, distance };    });    this.geoQuery.on("key_exited", key => {      console.log("MAP geofire key_exited", key);      this.setState({ dataLoading: true });      delete this.markersHolder[key];    });  }  componentWillUnmount() {    console.log("map unmount");    this.geoQuery.cancel();  }  static getDerivedStateFromProps(props, state) {    if (      props.orgsDetailList.newAdded &&      state.orgsSearchedID.indexOf(props.orgsDetailList.newAdded) < 0    ) {      return {        orgsSearchedID: [props.orgsDetailList.newAdded, ...state.orgsSearchedID]      };    }    if (props.petsByOrg.list[state.focusedOrgID]) {      let dataObj = props.petsByOrg.list[state.focusedOrgID];      let tempArr = Object.keys(dataObj).map(petID => dataObj[petID]);      return { petsForCarousel: tempArr };    }    return null;  }  componentDidUpdate(prevProps, prevState, snapshot) {    if (this.state.focusedIntroPetIndex !== prevState.focusedIntroPetIndex) {      this.setState({        focusedIntroPetIndexPrev: prevState.focusedIntroPetIndex      });      this.anime_introCarouselSwipe.start(        this.state.anime_introCarouselSwipe.setValue(0)      );    }  }  radiusFitScreen = (longitudeDelta, latitude) => {    let zoom = Math.round(Math.log(360 / longitudeDelta) / Math.LN2);    let sPerPx =      10 *      156543.03392 *      Math.cos(latitude * Math.PI / 180) /      Math.pow(2, zoom);    this.setState({ radius: sPerPx });  };  updateRegionInScreen = region => {    if (this.timerForMap) {      clearTimeout(this.timerForMap);    }    this.timerForMap = setTimeout(() => {      this.setState({ region });    }, 100);  };  onSearchArea = (lat, lng, rad) => {    this.updateCriteria(lat, lng, rad);  };  updateCriteria = (lat, lng, rad) => {    this.geoQuery.updateCriteria({      center: [lat, lng],      radius: rad    });  };  setLoadingFalse = () => {    this.setState({ dataLoading: false });  };  markAnimateToCoord = markerData => {    let coordinate = {      latitude: markerData.location[0],      longitude: markerData.location[1]    };    this.mapContainer.map.animateToCoordinate(coordinate, 500);  };  onMapMarkPress = markerKey => {    this.setState({ focusedOrgID: markerKey, petsForCarousel: [] });    this.anime_bottomUIShowUp.start(      this.state.anime_bottomUIShowUp.setValue(0)    );    this.props.fetchOrgDetail(markerKey);    this.props.fetchPetsByOrg(markerKey);  };  // setFocusedPetIndex = id => {  //   this.setState({ focusedIntroPetIndex: id });  // };  profileIconToggle = () => {    if (this.state.isScrolledUp === false) {      this.setState({ isScrolledUp: true, isMapBlurEnabled: true });      Animated.parallel([        Animated.timing(this.state.anime_profileSwipe, {          toValue: 0,          tension: 1        }),        Animated.timing(this.state.anime_profileAfterSwipe, {          toValue: 300,          duration: 500,          delay: 500        })      ]).start();    } else {      this.state.anime_profileAfterSwipe.setValue(0);      this._profileSV.scrollTo({ y: 0 });      Animated.parallel([        Animated.timing(this.state.anime_profileSwipe, {          toValue: 300,          tension: 1        }),        Animated.timing(this.state.anime_profileAfterSwipe, {          toValue: 0        })      ]).start(this.setState({ isScrolledUp: false, isMapBlurEnabled: false }));    }  };  toPetDetail = petObj => {    this.props.navigation.navigate("mapPetDetail", { petObj: petObj });  };  render() {    let focusedOrg =      this.props.orgsDetailList.list[this.state.focusedOrgID] || {};    let focusedPet = this.state.petsForCarousel[      this.state.focusedIntroPetIndex    ] || { pictures: [] };    const colorIndex = this.state.focusedIntroPetIndex % COLORS.length;    //const colorIndex = (this.state.focusedIntroPetIndex + 1) % GRADIENTS.length;    const introTextScroll = this.state.anime_introCarouselSwipe.interpolate({      inputRange: [0, 150, 300],      outputRange: [0, -120, 0],      extrapolate: "clamp"    });    const introFade = this.state.anime_profileSwipe.interpolate({      inputRange: [0, 200, 300],      outputRange: [0, 0, 1],      extrapolate: "clamp"    });    const introTransX = this.state.anime_profileSwipe.interpolate({      inputRange: [0, 300],      outputRange: [150, 0],      extrapolate: "clamp"    });    const profileFade = this.state.anime_profileSwipe.interpolate({      inputRange: [0, 200, 300],      outputRange: [1, 0, 0],      extrapolate: "clamp"    });    const profileScale = this.state.anime_profileSwipe.interpolate({      inputRange: [0, 300],      outputRange: [0.9, 1],      extrapolate: "clamp"    });    const profileImageScale = this.state.anime_profileSwipe.interpolate({      inputRange: [0, 300],      outputRange: [1, 0.4],      extrapolate: "clamp"    });    const introProfileTransY = this.state.anime_profileSwipe.interpolate({      inputRange: [0, 300],      outputRange: [88 - PROFILE_MAX_Y, 0],      extrapolate: "clamp"    });    const iconRotate = this.state.anime_profileSwipe.interpolate({      inputRange: [0, 300],      outputRange: ["-180deg", "0deg"],      extrapolate: "clamp"    });    const introLineWidth = this.state.anime_profileSwipe.interpolate({      inputRange: [0, 300],      outputRange: ["0%", "60%"],      extrapolate: "clamp"    });    const introCarouselTransY = this.state.anime_bottomUIShowUp.interpolate({      inputRange: [0, 300],      outputRange: [INTRO_CAROUSEL_HEIGHT, 0],      extrapolate: "clamp"    });    const introCarouselSwipeBorder = this.state.anime_introCarouselSwipe.interpolate(      {        inputRange: [0, 150, 300],        outputRange: ["0deg", "5deg", "0deg"],        extrapolate: "clamp"      }    );    const profileListColorChange = this.state.anime_introCarouselSwipe.interpolate(      {        inputRange: [0, 300],        outputRange: [          COLORS[this.state.focusedIntroPetIndexPrev % COLORS.length],          COLORS[colorIndex]        ],        //outputRange: [GRADIENTS[this.state.focusedIntroPetIndexPrev % GRADIENTS.length], GRADIENTS[colorIndex]],        extrapolate: "clamp"      }    );    const profileImageFadeWhileSwipe = this.state.anime_introCarouselSwipe.interpolate(      {        inputRange: [0, 300],        outputRange: [0, 1],        extrapolate: "clamp"      }    );    const profileShowUpValue = this.state.anime_bottomUIShowUp.interpolate({      inputRange: [0, 300],      outputRange: [-SCREEN_HEIGHT, -PROFILE_MAX_Y]      //outputRange: [-300, 0]    });    const blurBackgroundMap = this.state.anime_profileSwipe.interpolate({      inputRange: [0, 300],      outputRange: [90, 0],      extrapolate: "clamp"    });    const profileDelayFadeIn = this.state.anime_profileAfterSwipe.interpolate({      inputRange: [0, 300],      outputRange: [0, 1],      extrapolate: "clamp"    });    const switchIconTranY = this.state.anime_profileSwipe.interpolate({      inputRange: [0, 300],      outputRange: [0, 0],      extrapolate: "clamp"    });    return (      <Animated.View style={{ overflow: "hidden", flex: 1 }}>        {this.state.dataLoading && (          <ModalSpinner            visible={this.state.dataLoading}            transparent={true}            animationType={"none"}            setLoadingFalse={this.setLoadingFalse}          />        )}        <MapContainer          ref={ref => (this.mapContainer = ref)}          geoMarkersCurrentSearchResults={            this.state.geoMarkersCurrentSearchResults          }          updateRegionInScreen={this.updateRegionInScreen}          radius={this.state.radius}          orgsDetailList={this.props.orgsDetailList}          onMapMarkPress={this.onMapMarkPress}        />        {/*search area button*/}        <Animated.View          style={{            zIndex: 9999,            position: "absolute",            width: 150,            left: (SCREEN_WIDTH - 150) / 2,            height: 60,            top: 100, //PROFILE_MAX_Y - 50, //(SCREEN_HEIGHT - 50) / 2,            //zIndex: 10,            opacity: introFade          }}        >          <SearchArea            leftOffset={SCREEN_WIDTH}            topOffset={PROFILE_MAX_Y}            setR10={() => this.setState({ radius: 10 })}            setR20={() => this.setState({ radius: 20 })}            radius={this.state.radius}            onSearchArea={() =>              this.onSearchArea(                this.state.region.latitude,                this.state.region.longitude,                this.state.radius              )            }          />        </Animated.View>        {/*map blur element*/}        <AnimatedBlurView          tint="dark"          intensity={blurBackgroundMap}          style={[            StyleSheet.absoluteFill,            { display: this.state.isMapBlurEnabled ? "flex" : "none" }          ]}        />        {/*burger button*/}        {/*<View style={{ zIndex: 9999, position: "absolute", top: 44, flexDirection: "row" }}>          <Icon            style={{ position: "absolute", left: 20, zIndex: 1 }}            name="menu"            color={"white"}            size={30}            type="materialicons"            onPress={() => {              console.log("drawerOpen", true);              this.setState({ drawerOpen: true });            }}          />          <View style={{ flexGrow: 1 }}>            <Text style={{ textAlign: "center", color: "white" }}>              LatLng:{latitude.toFixed(2)}|{longitude.toFixed(2)}            </Text>            <Text style={{ textAlign: "center", color: "white" }}>              Delta:{latitudeDelta.toFixed(2)}|{longitudeDelta.toFixed(2)}            </Text>          </View>        </View>*/}        <Animated.View          style={{            backgroundColor: "rgba(0,0,0,.2)",            zIndex: 100,            position: "absolute",            borderRadius: 0,            overflow: "hidden",            left: 0,            right: 0,            //bottom:-SCREEN_HEIGHT+300,            //top:profileShowUpValue,            bottom: profileShowUpValue,            height: SCREEN_HEIGHT, //PROFILE_MIN_Y,            //backgroundColor: profileListColorChange, //COLORS[colorIndex],            transform: [{ translateY: introProfileTransY }]          }}          {...this._panResponder.panHandlers}        >          <View            style={{              zIndex: 100,              width: 50,              marginTop: 10,              height: 2,              backgroundColor: "white",              alignSelf: "center"            }}          />          {/*color string*/}          <Animated.View            style={{              position: "absolute",              width: introLineWidth,              height: "100%",              left: "20%",              backgroundColor: profileListColorChange, //COLORS[this.state.focusedIntroPetIndex],              opacity: 1            }}          />          <Animated.View            style={{              position: "absolute",              width: "100%",              height: "100%",              opacity: profileFade,              flex: 1            }}          />          <LinearGradient            colors={["rgba(255,255,255,0)", "rgba(255,255,255,1)"]}            start={[0, 0.5]}            end={[0, 1]}          />          {this.state.petsForCarousel.length > 0 && (            <Animated.View              style={[                {                  padding: 0,                  position: "absolute",                  right: 10,                  top: PROFILE_INTRO_OFFSET / 2,                  zIndex: 30,                  transform: [                    { rotate: iconRotate },                    { translateY: switchIconTranY }                  ]                },                styles.swipeIcon              ]}            >              <AnimatedIcon                name="keyboard-arrow-up"                color={COLORS[colorIndex]}                size={30}                type="materialicons"                onPress={this.profileIconToggle}              />            </Animated.View>          )}          <ScrollView            style={{              backgroundColor: "pink",              overflow: "hidden",              //height: SCREEN_HEIGHT - 400,              //width:SCREEN_HEIGHT            }}            ref={ref => (this._profileSV = ref)}            scrollEnabled={this.state.isScrolledUp}            scrollEventThrottle={16}            //contentContainerStyle={{padding:21}}            onScroll={event => {              this.scrollOffset = event.nativeEvent.contentOffset.y;            }}          >            {/* intro */}            <View style={{ flex: 1 }}>              <Animated.View                style={{                  opacity: introFade,                  transform: [{ translateX: introTransX }]                }}              >                <View                  style={{                    marginTop: 0                  }}                >                  {focusedOrg && (                    <Animated.Text                      ellipsizeMode={"head"}                      numberOfLine={1}                      style={{                        flex: 1,                        color: "white",                        width: SCREEN_WIDTH - 50,                        marginHorizontal: 10,                        top: 5,                        //marginTop: 10,                        fontSize: 16,                        fontWeight: "600"                      }}                    >                      {focusedOrg.name}                    </Animated.Text>                  )}                  {focusedPet && (                    <Animated.Text                      numberOfLine={1}                      style={{                        //position:'absolute',                        //top:35,                        color: "white",                        marginHorizontal: 10,                        fontSize: 20,                        fontWeight: "800",                        transform: [{ translateX: introTextScroll }]                      }}                    >                      {focusedPet.name}                    </Animated.Text>                  )}                </View>              </Animated.View>            </View>            <View style={{ flex: 1, backgroundColor: "white" }}>              <Animated.View                style={[                  {                    position: "absolute",                    top: 0,                    left: -30,                    zIndex: 2,                    height: SCREEN_HEIGHT * 0.3,                    opacity: profileFade                  },                  { transform: [{ scale: profileImageScale }] }                ]}              >                {/*Profile              {focusedPet.pictures.length > 0 && <Image style={{height:300,width:SCREEN_WIDTH}} source={{ uri: focusedPet.pictures[0].fullsizeUrl }} />}*/}                <Carousel                  layout={"stack"}                  ref={ref => (this._carouselProfile = ref)}                  data={focusedPet.pictures}                  renderItem={this.renderProfileItem}                  sliderWidth={SCREEN_WIDTH} //carousel width                  itemWidth={SCREEN_WIDTH - 100}                  hasParallaxImages={true}                  lockScrollWhileSnapping                  inactiveSlideScale={0.7}                  inactiveSlideOpacity={1}                  onScroll={() =>                    this.setState({                      focusedProfileImageIndex: this._carouselProfile                        .currentIndex                    })                  }                />              </Animated.View>              <Animated.View                style={{                  marginHorizontal: 50,                  paddingTop: 150,                  top: SCREEN_HEIGHT * 0.1,                  backgroundColor: profileListColorChange,                  opacity: profileDelayFadeIn,                  zIndex: 1                  //top:-300,                  //paddingTop:200,                  //height:400,                  //marginBottom: INTRO_CAROUSEL_HEIGHT,                }}              >                <View style={{ top: 0, marginVertical: 0, height: 70 }}>                  <Pagination                    activeDotIndex={this.state.focusedProfileImageIndex}                    dotsLength={                      focusedPet.pictures ? focusedPet.pictures.length : 0                    }                    //containerStyle={{backgroundColor:'gray',borderRadius:2,width:300}}                    dotColor={"black"}                    inactiveDotColor={"black"}                    dotStyle={{                      width: 20,                      height: 2,                      borderRadius: 0                    }}                    inactiveDotStyle={{                      width: 10,                      height: 10                    }}                  />                </View>                <ProfileView                  focusedPet={focusedPet}                  petObj={focusedPet}                  flag={this.state.petSwitchFlag}                  themeColor={COLORS[colorIndex]}                  colorIndex={colorIndex}                  toPetDetail={this.toPetDetail}                />              </Animated.View>            </View>          </ScrollView>          {/*</LinearGradient>*/}        </Animated.View>        <Animated.View          style={{            //opacity: introFade,            position: "absolute",            //left: SCREEN_WIDTH * 0.05,            //backgroundColor: 'white',//this.state.isScrolledUp ? "white" : "transparent",            //opacity:introFade,            width: SCREEN_WIDTH,            justifyContent: "center",            alignItems: "center",            zIndex: 100, //this.state.isScrolledUp ? 99 : 100,            bottom: 20, //20,            height: INTRO_CAROUSEL_HEIGHT - 50,            transform: [{ translateY: introCarouselTransY }]          }}        >          <Animated.View            style={{              width: SCREEN_WIDTH,              height: INTRO_CAROUSEL_HEIGHT,              position: "absolute",              opacity: profileFade            }}          />          {this.state.petsForCarousel.length > 0 ? (            <Carousel              //layout={"stack"}              ref={ref => (this._carouselIntro = ref)}              data={this.state.petsForCarousel}              renderItem={this.renderIntroItem}              sliderWidth={SCREEN_WIDTH} //carousel width              itemWidth={INTRO_CAROUSEL_HEIGHT * SCREEN_RATIO * 1.4}              lockScrollWhileSnapping              inactiveSlideScale={1}              inactiveSlideOpacity={1}              //inactiveSlideShift={-2}              //showsHorizontalScrollIndicator              //hasParallaxImages={true}              slideStyle={{                //width:100,                alignSelf: "center",                //marginHorizontal:50,                //paddingVertical:20,                height: INTRO_CAROUSEL_HEIGHT,                width: INTRO_CAROUSEL_HEIGHT * SCREEN_RATIO * 1.4                //backgroundColor: "black",                //padding:2                //opacity:this.state.isScrolledUp?.8:1              }}              containerCustomStyle={{                height: INTRO_CAROUSEL_HEIGHT                //bottom: 50,              }}              onBeforeSnapToItem={() => {                this.setState({ petSwitchFlag: !this.state.petSwitchFlag });                this._carouselProfile.snapToItem(0);                //this.anime_introCarouselSwipe.start(this.state.anime_introCarouselSwipe.setValue(150))              }}              onScroll={() => {                this.setState({                  focusedIntroPetIndex: this._carouselIntro.currentIndex                });                //this._carouselProfile.snapToItem(0); //when focusedPet change, reset profile index              }}            />          ) : (            <Spinner size={"large"} color={"#ffffff"} />          )}        </Animated.View>      </Animated.View>    );  }  renderProfileItem = ({ item, index }) => {    const { fullsizeUrl, species } = item;    return (      <View        style={{          flexGrow: 1,          //borderRadius: 0,          overflow: "hidden"        }}      >        <Image          //defaultSource={require("../../assets/peticon1.png")}          defaultSource={            species === "Cat" ? loadingImages[0] : loadingImages[1]          }          source={{ uri: fullsizeUrl }}          style={{            flexGrow: 1,            width: "100%",            height: "100%",            position: "absolute"          }}        />      </View>    );  };  renderIntroItem = ({ item, index }) => {    const { name, animalID, orgID, pictures, species } = item;    return (      <View        style={{          flexGrow: 1,          borderRadius: 0,          overflow: "hidden",          margin: 5,          flexDirection: "column",          shadowColor: "red",          shadowOffset: { height: 10 },          shadowOpacity: 1        }}      >        <View style={{ flex: 1 }}>          <Image            //defaultSource={require("../../assets/peticon1.png")}            defaultSource={              species === "Cat" ? loadingImages[0] : loadingImages[1]            }            source={{ uri: pictures[0].fullsizeUrl }}            style={{              height: INTRO_CAROUSEL_HEIGHT,              width: INTRO_CAROUSEL_HEIGHT * SCREEN_RATIO * 1.4,              position: "absolute",              top: 0,              left: 0            }}          />        </View>      </View>    );  };}const styles = StyleSheet.create({  swipeIcon: {    backgroundColor: "white",    //borderColor: "white",    height: 30,    width: 30,    padding: 0  },  profileTitleContainer: {    zIndex: 999,    //marginLeft:SCREEN_WIDTH*.5,    position: "absolute",    paddingVertical: 5,    paddingHorizontal: 25,    bottom: 0,    alignSelf: "center"    //width:300,    //height:50    //width: SCREEN_WIDTH * .5,    //left: SCREEN_WIDTH * 0.1,    //marginLeft: SCREEN_WIDTH,    //transform: [{ translateX: profileDelayMoveLeft }]  }});function mapStateToProps(state) {  return {    petsByOrg: state.petsByOrg,    orgsDetailList: state.orgsDetailList,    likedPets: state.likedPets  };}MapScreen.propTypes = {};MapScreen.defaultProps = {  petsByOrg: {},  orgsDetailList: {    //newAdded:null,    list: {}  }};export default connect(mapStateToProps, actions)(MapScreen);