import React, { Component } from "react";import PropTypes from "prop-types";import { connect } from "react-redux";import { Animated, Dimensions, Easing, Image, PanResponder, SafeAreaView, StyleSheet, Text, View } from "react-native";import * as actions from "../actions";import Icon from "react-native-vector-icons/MaterialIcons";import GeoFire from "geofire";import { firedb } from "../modules/firebase";import MapContainer from "../components/Map/MapContainer";import { defaultRegion } from "../../config/setting/defaultValues";import ModalContainer from "../components/Map/ModalContainer";import SearchArea from "../components/Map/SearchArea";import Carousel from "react-native-snap-carousel";import DEFAULT_SAMPLE from "../assets/sampleData";let { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get("window");SCREEN_HEIGHT -= 78;const CAROUSEL_HEIGHT = 200;const PROFILE_MIN_Y = 240;const TAB_HEIGHT = 50;const CARD_MAX_Y = SCREEN_HEIGHT - PROFILE_MIN_Y;class MapScreen extends Component {  // noinspection JSUnusedGlobalSymbols 1  static navigationOptions = {    title: "Map",    header: null,    tabBarIcon: ({ tintColor }) => {      return <Icon name="place" color={tintColor} size={20} type="materialicons" />;    },    drawerLabel: "MapScreen"  };  constructor(props) {    super(props);    this.state = {      region: defaultRegion,      radius: 10,      dataLoading: false,      orgsSearchedID: [],      petsForCarousel: DEFAULT_SAMPLE,      focusedOrgID: -1,      focusedPetIndex: 0,      //these two only contain geo locations from firedb      geoMarkersCurrentSearchResults: {},      geoMarkersAllSearchResultsSaved: {},      //animations      anime_carouselJumpUpValue: new Animated.Value(0),      anime_carouselSwipeValue: new Animated.Value(300),      isScrollEnabled: false    };    this.scrollOffset = 0;    this.anime_carouselJumpUp = Animated.timing(this.state.anime_carouselJumpUpValue, {      toValue: 1,      easing: Easing.linear    });    this._panResponder = PanResponder.create({      onMoveShouldSetPanResponder: (evt, gestureState) => {        const { dx, dy, vx, vy, y0 } = gestureState;        if (          (this.state.isScrollEnabled &&            this.scrollOffset <= 0 &&            gestureState.dy > 0 &&            Math.abs(gestureState.dx) < Math.abs(gestureState.dy * 4)) ||          (!this.state.isScrollEnabled &&            gestureState.dy <= 0 &&            Math.abs(gestureState.dx) < Math.abs(gestureState.dy * 4))        ) {          console.log("onMoveShouldSet");          return true;        }        return false;      },      onPanResponderGrant: (evt, gestureState) => {        //if(gestureState.y0>CARD_MAX_Y||gestureState.y0<PROFILE_MIN_Y) {        this.state.anime_carouselSwipeValue.extractOffset();        //console.log("Responder Grant--", this.state.anime_carouselSwipeValue);        //this.state.anime_carouselSwipeValue.setValue(gestureState.dy)      },      onPanResponderMove: (evt, gestureState) => {        //if(gestureState.y0>CARD_MAX_Y||gestureState.y0<PROFILE_MIN_Y) {        //console.log("Responder Move--", this.state.anime_carouselSwipeValue, gestureState);        // if (        //   (!this.state.isScrollEnabled && gestureState.moveY > CARD_MAX_Y) ||        //   (this.state.isScrollEnabled && gestureState.moveY < PROFILE_MIN_Y)        // ) {        this.state.anime_carouselSwipeValue.setValue(gestureState.dy);        // }        //}        // Animated.event([        //   null,        //   {        //     dy: this.state.anime_carouselSwipeValue        //   }        // ])      },      onPanResponderRelease: (evt, gestureState) => {        this.state.anime_carouselSwipeValue.flattenOffset()        const { dy, vy, y0, moveY } = gestureState;        if (moveY > CARD_MAX_Y) {          console.log("1");          Animated.timing(this.state.anime_carouselSwipeValue, {            toValue: 0,            tension: 1          }).start();        } else if (moveY < PROFILE_MIN_Y) {          console.log("2");          Animated.timing(this.state.anime_carouselSwipeValue, {            toValue: 0,            tension: 1          }).start();        } else if (dy <= 0) {          console.log("3");          Animated.timing(this.state.anime_carouselSwipeValue, {            toValue: 0,            tension: 1          }).start(() => this.setState({ isScrollEnabled: true }));          //this.state.anime_carouselSwipeValue.setValue(-CARD_MAX_Y)        } else if (dy > 0) {          console.log("4");          Animated.timing(this.state.anime_carouselSwipeValue, {            toValue: 300,            tension: 1          }).start(() => this.setState({ isScrollEnabled: false }));          //this.state.anime_carouselSwipeValue.setValue(CARD_MAX_Y)        }      }    });    this.markersHolder = {};    this.geoFire = new GeoFire(firedb.ref("orgs"));    this.geoQuery = this.geoFire.query({      center: [this.state.region.latitude, this.state.region.longitude],      radius: 10    });    this.geoQuery.on("ready", async () => {      this.setState({        geoMarkersCurrentSearchResults: this.markersHolder,        geoMarkersAllSearchResultsSaved: {          ...this.state.geoMarkersAllSearchResultsSaved,          ...this.markersHolder        },        dataLoading: false      });    });    this.geoQuery.on("key_entered", (key, location, distance) => {      this.setState({ dataLoading: true });      this.markersHolder[key] = { key, location, distance };    });    this.geoQuery.on("key_exited", key => {      this.setState({ dataLoading: true });      delete this.markersHolder[key];    });  }  _start_anime_carouselJumpUp = () => {    this.anime_carouselJumpUp.start(this.state.anime_carouselJumpUpValue.setValue(0));  };  componentDidMount() {    navigator.geolocation.getCurrentPosition(pos => {      const longitude = pos.coords.longitude;      const latitude = pos.coords.latitude;      this.setState({ region: { ...this.state.region, latitude, longitude } });    });  }  static getDerivedStateFromProps(props, state) {    if (props.orgsDetailList.newAdded && state.orgsSearchedID.indexOf(props.orgsDetailList.newAdded) < 0) {      return {        orgsSearchedID: [props.orgsDetailList.newAdded, ...state.orgsSearchedID]      };    }    if (props.petsByOrg.list[state.focusedOrgID]) {      let dataObj = props.petsByOrg.list[state.focusedOrgID];      let tempArr = Object.keys(dataObj).map(petID => dataObj[petID]);      return { petsForCarousel: tempArr };    }    // if (this.state.focusedOrgID && props.petsByOrg[this.state.focusedOrgID]!==this.state.petsForCarousel){    //   return {petsForCarousel:props.petsByOrg[this.state.focusedOrgID]}    // }    return null;  }  radiusFitScreen = (longitudeDelta, latitude) => {    let zoom = Math.round(Math.log(360 / longitudeDelta) / Math.LN2);    let sPerPx = 10 * 156543.03392 * Math.cos(latitude * Math.PI / 180) / Math.pow(2, zoom);    this.setState({ radius: sPerPx });  };  updateRegionInScreen = region => {    if (this.timerForMap) {      clearTimeout(this.timerForMap);    }    this.timerForMap = setTimeout(() => {      this.setState({ region });    }, 100);  };  onSearchArea = (lat, lng, rad) => {    this.updateCriteria(lat, lng, rad);  };  updateCriteria = (lat, lng, rad) => {    this.geoQuery.updateCriteria({      center: [lat, lng],      radius: rad    });  };  setLoadingFalse = () => {    this.setState({ dataLoading: false });  };  //for org  onPanItemPress = id => {    this.markAnimateToCoord(this.state.geoMarkersAllSearchResultsSaved[id]);    this.props.navigation.navigate("mapDetail", {      //TODO rewrite      focusedOrg: this.props.orgsDetailList.list[id]    });  };  markAnimateToCoord = markerData => {    let coordinate = {      latitude: markerData.location[0],      longitude: markerData.location[1]    };    this.mapContainer.map.animateToCoordinate(coordinate, 500);  };  onMapMarkPress = markerKey => {    this.setState({ focusedOrgID: markerKey, petsForCarousel: [] });    this._start_anime_carouselJumpUp();    this.props.fetchOrgDetail(markerKey);    this.props.fetchPetsByOrg(markerKey);  };  // setFocusedPetIndex = id => {  //   this.setState({ focusedPetIndex: id });  // };  render() {    const titleFadeOut = this.state.anime_carouselSwipeValue.interpolate({      inputRange: [0, 200, 300],      outputRange: [0, 0, 1],      extrapolate: "clamp"    });    const titleTransX = this.state.anime_carouselSwipeValue.interpolate({      inputRange: [0, 300],      outputRange: [ 150, 0],      extrapolate: "clamp"    });    const scaleInterpolate = this.state.anime_carouselSwipeValue.interpolate({      inputRange: [0, 300],      outputRange: [1, 0.9],      extrapolate: "clamp"    });    const topInterpolate = this.state.anime_carouselSwipeValue.interpolate({      inputRange: [0, 300],      outputRange: [50, 0],      extrapolate: "clamp"    });    const heightInterpolate = this.state.anime_carouselSwipeValue.interpolate({      inputRange: [0, 150, 300],      outputRange: [500, 100, 100],      extrapolate: "clamp"    });    const carouselTop = this.state.anime_carouselSwipeValue.interpolate({      inputRange: [0, 300],      outputRange: [44, 10],      extrapolate: "clamp"    });    const translateYInterpolate = this.state.anime_carouselSwipeValue.interpolate({      inputRange: [0, 300 /*CARD_MAX_Y*/],      outputRange: [-CARD_MAX_Y, 0],      extrapolate: "clamp"    });    const animatedCarouselTrans = {      transform: [        {          translateY: translateYInterpolate        }      ]    };    const animatedTitle = this.state.anime_carouselSwipeValue.interpolate({      inputRange: [0, CARD_MAX_Y],      outputRange: [0, 1],      extrapolate: "clamp"    });    const scrollStyles = {      //opacity: opacityInterpolate      transform: [        {          translateY: translateYInterpolate        }      ]    };    const carouselJumpUp = this.state.anime_carouselJumpUpValue.interpolate({      inputRange: [0, 1],      outputRange: [SCREEN_HEIGHT, CARD_MAX_Y]      //outputRange: [-300, 0]    });    const { orgsDetailList, petsByOrg } = this.props;    const focusedOrg = orgsDetailList[this.state.focusedOrgID];    const { latitude, longitude, latitudeDelta, longitudeDelta } = this.state.region;    return (      <SafeAreaView style={{ flex: 1 }}>        <View          style={{            width: "100%",            height: 2,            backgroundColor: "gray",            position: "absolute",            zIndex: 999,            top: CARD_MAX_Y          }}        />        <ModalContainer visible={this.state.dataLoading} setLoadingFalse={this.setLoadingFalse} />        <MapContainer          ref={ref => (this.mapContainer = ref)}          dataLoading={this.state.dataLoading}          geoMarkersCurrentSearchResults={this.state.geoMarkersCurrentSearchResults}          updateRegionInScreen={this.updateRegionInScreen}          onRegionChangeComplete={this.onRegionChangeComplete}          radius={this.state.radius}          orgsDetailList={this.props.orgsDetailList}          navigation={this.props.navigation}          onMapMarkPress={this.onMapMarkPress}        >          <SearchArea            SCREEN_WIDTH={SCREEN_WIDTH}            CARD_MAX_Y={CARD_MAX_Y}            setR10={() => this.setState({ radius: 10 })}            setR50={() => this.setState({ radius: 50 })}            radius={this.state.radius}            onSearchArea={() => this.onSearchArea(latitude, longitude, this.state.radius)}          />        </MapContainer>        {/*burger button*/}        <View style={{ position: "absolute", top: 40, flexDirection: "row" }}>          <Icon            style={{ position: "absolute", right: 25 }}            name="menu"            color={"white"}            size={30}            type="materialicons"            onPress={() => {              this.props.navigation.navigate("DrawerOpen");            }}          />          <View style={{ flexGrow: 1 }}>            <Text style={{ textAlign: "center", color: "white" }}>              LatLng:{latitude.toFixed(2)}|{longitude.toFixed(2)}            </Text>            <Text style={{ textAlign: "center", color: "white" }}>              Delta:{latitudeDelta.toFixed(2)}|{longitudeDelta.toFixed(2)}            </Text>          </View>        </View>        <Animated.View          style={{            position: "absolute",            padding:10,            left: 0,            right: 0,            zIndex: 10,            top: CARD_MAX_Y, //carouselJumpUp,            height: SCREEN_HEIGHT, //PROFILE_MIN_Y,            backgroundColor: "white",            transform: [{ translateY: translateYInterpolate }]          }}          {...this._panResponder.panHandlers}        >          <View style={{ flex: 1 }}>            {this.state.petsForCarousel[this.state.focusedPetIndex] && (              <Animated.View                style={{                  opacity: titleFadeOut,                  //marginLeft: titleMarginLeft                  transform:[{translateX: titleTransX}]                }}              >                {orgsDetailList.list[this.state.focusedOrgID] && (                  <Animated.Text                    style={{                      fontSize: 16,                      fontWeight: "500",                    }}                  >                    {orgsDetailList.list[this.state.focusedOrgID].name}                  </Animated.Text>                )}                <Animated.Text                  style={{                    fontSize: 22,                    fontWeight: "600",                  }}                >                  {this.state.petsForCarousel[this.state.focusedPetIndex].name}                </Animated.Text>              </Animated.View>            )}          </View>        </Animated.View>        <View style={{ zIndex: 20, height: 150, bottom: 10 }}>          <Carousel            ref={ref => (this._carousel = ref)}            data={this.state.petsForCarousel}            renderItem={this.renderItem}            sliderWidth={SCREEN_WIDTH} //carousel width            itemWidth={SCREEN_WIDTH * 0.6}            firstItem={0}            lockScrollWhileSnapping            showsHorizontalScrollIndicator            //useScrollView            onScroll={() =>              this.setState({                focusedPetIndex: this._carousel.currentIndex              })            }            slideStyle={{ height: 150, backgroundColor: "red" }}          />        </View>      </SafeAreaView>    );  }  renderItem = ({ item, index }) => {    const { name, orgID, pictures } = item;    const fadeInterpolate = this.state.anime_carouselSwipeValue.interpolate({      inputRange: [0, 300],      outputRange: [1, 0],      extrapolate: "clamp"    });    return (      <View        style={{          flexGrow: 1,          backgroundColor: "red"        }}      >        <Image          source={{ uri: pictures[0].large.url }}          style={{            flexGrow: 1,            height: "100%",            width: "100%",            position: "absolute",            top: 0,            left: 0          }}        />        {/*<View style={{flexGrow: 1,          marginBottom: 10,          backgroundColor: "red"}}>          <Image            source={{ uri: pictures[0].large.url }}            style={{flexGrow: 1,              height: "100%",              width: "100%",              position: "absolute",              top: 0,              left: 0}}          />          <View style={{ backgroundColor: "black", opacity: 0.6 }}>          <Text style={styles.slideTitle}>{name}</Text>          </View>        </View>*/}        {/* <Card          //containerStyle={{ borderRadius: 15 }}          image={{ uri: pictures[0].large.url }}        >          <Animated.View style={{ opacity: fadeInterpolate }}>            <View>              <Text                style={{                  color: "white",                  fontSize: 20,                  flexDirection: "row",                  justifyContent: "space-between"                }}              >                <Text style={{ flex: 1 }}>{name}</Text>                <Text style={{ flex: 1 }}>{orgID}</Text>              </Text>            </View>          </Animated.View>        </Card>*/}      </View>    );  };}const styles = StyleSheet.create({  container: {    flex: 1    //justifyContent: "center"  },  panContainer: {    flexDirection: "column",    //width: 200,    left: 0, //(SCREEN_WIDTH - 200)/2,    top: 100,    zIndex: 1,    position: "absolute",    backgroundColor: "white"  },  centerPointer: {    flexDirection: "column",    width: 200,    height: 100,    opacity: 1,    backgroundColor: "white",    borderRadius: 25,    zIndex: 10  }});function mapStateToProps(state) {  return {    jobsList: state.jobsList.results,    petsByOrg: state.petsByOrg,    orgsDetailList: state.orgsDetailList  };}MapScreen.propTypes = {  jobsList: PropTypes.array.isRequired};MapScreen.defaultProps = {  jobsList: [],  petsByOrg: {},  orgsDetailList: {    //newAdded:null,    list: {}  }};export default connect(mapStateToProps, actions)(MapScreen);